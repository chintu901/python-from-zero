# Advanced List Comprehensions Concepts

## List Comprehensions with Functions

List comprehensions become even more powerful when combined with functions. Instead of writing long transformation logic inside the comprehension, you can call **built-in** or **custom functions** to keep the code clean and readable.

This improves:
- Code clarity
- Reusability
- Maintainability

**Using Built-in Functions**

You can directly use Python’s **built-in functions** inside list comprehensions.

**Example: Using abs()**

``` python 
numbers = [-3, -1, 0, 2, 4]
absolute_values = [abs(num) for num in numbers] # [3, 1, 0, 2, 4]
```

**Using String Methods**

``` python 
names = ["alice", "BOB", "charlie"]
formatted = [name.capitalize() for name in names]   # ['Alice', 'Bob', 'Charlie']

```

**Using Custom Functions**

You can define your own function and call it inside a list comprehension.

Example:-
``` python
def square(x):
    return x * x

numbers = [1, 2, 3, 4]
squares = [square(num) for num in numbers]  # [1, 4, 9, 16]
```


Example with Condition + Function:-

``` python
def is_even(x):
    return x % 2 == 0

numbers = range(1, 11)
even_numbers = [num for num in numbers if is_even(num)]
```

## List Comprehensions with Multiple Iterables

List comprehensions can include multiple `for` **clauses**, allowing you to work with more than one iterable.

This is similar to writing nested loops.

**Basic Syntax with Multiple Iterables**
``` python 
[expression for item1 in iterable1 for item2 in iterable2]
```

**This behaves like:**

``` python
for item1 in iterable1:
    for item2 in iterable2:
        ...
```

**Example:**
``` python
colors = ["red", "blue"]
sizes = ["S", "M"]

combinations = [(color, size) for color in colors for size in sizes]
```

Result:

``` python
[('red', 'S'), ('red', 'M'), ('blue', 'S'), ('blue', 'M')]
```

### Important Behaviour

The order of `for` clauses matters.

``` python
[(x, y) for x in A for y in B]
```
means:
- Loop through A first
- For each element of A, loop through B

## Performance and Memory Considerations

List comprehensions are not just shorter — they are also generally **more efficient** than traditional loops. However, understanding why and when that matters is important.

### Why List Comprehensions Are Often Faster

List comprehensions are typically faster than equivalent `for` loops because:
- They are optimized internally by Python.
- They avoid repeated method calls like `.append()`.
- The looping logic is handled in a more compact internal structure.

**Example Comparison**

Traditional loop:

``` python 
result = []
for i in range(1000000):
    result.append(i * 2)
```

List comprehension:

``` python 
result = [i * 2 for i in range(1000000)]
```

[!IMPORTANT]
> For small datasets, the performance difference is minimal.
> You should not use list comprehensions only for speed.
> ✔ Readability should always be your first priority.

### Memory Usage Considerations

A list comprehension creates a full list in memory immediately.

Example:
``` python 
numbers = [i for i in range(1000000)]
```

This stores all one million values in memory at once.

If the dataset is very large, this can increase memory usage significantly.

## Alternatives to List Comprehensions

Although list comprehensions are **powerful and Pythonic**, they are not the only way to transform or filter data.

Understanding alternatives helps you choose the right tool for the situation.

1️⃣ **Generator Expressions**

Generator expressions look similar to list comprehensions but use parentheses `()` instead of brackets `[]`.

``` python 
gen = (i * 2 for i in range(5))
```

> This does not create a full list immediately.

Instead:
- It generates values one at a time
- It saves memory
- It is lazy (evaluated only when needed)

Converting to a list:

``` python 
list(gen)
```

**When to Use Generators**
- Very large datasets
- Streaming data
- Memory-sensitive applications

2️⃣ `map()` Function

The `map()` function applies a function to each element of an iterable.

``` python 
numbers = [1, 2, 3, 4]
result = list(map(lambda x: x * 2, numbers))
```

Equivalent list comprehension:

``` python
result = [x * 2 for x in numbers]
```
> ✔ List comprehensions are usually more readable than `map()` with `lambda`.


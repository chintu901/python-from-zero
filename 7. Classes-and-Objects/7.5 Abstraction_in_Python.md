# Abstraction in Python

**Abstraction** is a concept in Object-Oriented Programming that means **hiding unnecessary details and showing only the important features** to the user. In simple words, it focuses on what an object does, not how it does it.

Abstraction exists because real programs can be very complex. If users or developers had to understand every internal detail, software would be hard to use and maintain. By hiding internal logic, abstraction makes systems **easier to use**, **safer**, and **more organized**.

In Python, abstraction is usually implemented using **abstract classes and abstract methods**, where you define what a class should do, but not how it should do it. The child classes then provide the actual implementation.

Abstraction is important in professional programming because it **reduces complexity**, **improves code readability**, and **enforces a clear structure** in large projects.

``` python
from abc import ABC, abstractmethod

# Abstract class
class Shape(ABC):

    @abstractmethod
    def area(self):
        pass
```

## Real-World Analogy of Abstraction

A common real-world example of abstraction is a car. When you drive a car, you use the steering wheel, pedals, and gear system. You don’t need to know how the engine works internally. The complex engine logic is hidden, and you only interact with simple controls.

Another example is a mobile phone. You tap icons to call, message, or browse the internet, but you don’t see how the operating system, hardware, and network protocols work internally. The phone hides all that complexity from you.

In programming, abstraction works the same way. A developer may use a class or function without knowing its internal code. They only care about what it does and how to use it. This makes large systems possible, where different developers work on different parts without understanding every detail.


## Abstract Classes in Python

An abstract class is a class that is **not meant to be used directly to create objects**. Instead, it is used as a blueprint for other classes. It defines what methods a child class must have, but it does not provide the full implementation.

Abstract classes exist because sometimes you want to force all child classes to follow a specific structure. For example, every Shape should have an area() method, but the formula for area is different for each shape. So, you define area() in the abstract class, and child classes must implement it.

In Python, you usually cannot create objects from an abstract class. Its main purpose is design and structure, not direct use.

``` python
class Shape:
    def area(self):
        pass
```
This looks like an abstract class, but Python does not enforce it yet. This is just a conceptual abstraction. To enforce abstraction, Python provides the `abc` module.

## The `abc` Module and `ABC` Class

Python provides the `abc` module (Abstract Base Classes) to properly create abstract classes. The `ABC` class is used to make a class abstract, and `@abstractmethod` is used to define abstract methods.

The `abc` module exists because Python is dynamic and does not enforce strict rules by default. Using `ABC` and `@abstractmethod` helps developers enforce structure and prevent mistakes in large projects.

``` python
from abc import ABC, abstractmethod

class Shape(ABC):

    @abstractmethod
    def area(self):
        pass
```

Now, any child class must implement `area()`:

``` python
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius
```

If you try to create an object of Shape:

``` python
s = Shape()     # Error
```

Python will raise an error because `Shape` is abstract.

> [!NOTE]
> The `abc` module and `ABC` class are used to create real abstract classes in Python and force child classes to implement required methods.

## Abstract Methods and Why They Matter

An **abstract method** is a method that is declared in an abstract class but does not have a real implementation. It only defines the method name and purpose, not the logic. This means the child class must **implement this method**, or Python will not allow the class to be used.

Abstract methods exist because they enforce rules in program design. They make sure that every child class follows the same structure and provides required functionality. Without abstract methods, developers might forget to implement important methods, leading to broken or incomplete systems.

In Python, abstract methods are created using the `@abstractmethod` decorator from the abc module.

``` python
from abc import ABC, abstractmethod

class Shape(ABC):

    @abstractmethod
    def area(self):
        pass
```
Here, `area()` is an abstract method. It has no logic, but it tells every child class:
“You must define an `area()` method.”

> [!NOTE]
> This is important in professional software because large teams work on the same codebase. Abstract methods ensure consistency, structure, and reliability.

## Implementing Abstract Methods in Child Classes

When a class inherits from an abstract class, it **must implement all abstract methods**, or Python will treat it as an abstract class too and prevent object creation.

This ensures that every usable class has complete functionality.

``` python
from abc import ABC, abstractmethod

class Shape(ABC):

    @abstractmethod
    def area(self):
        pass
```

Child class implementation:

``` python
class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width
```

Using the class:

``` python
r = Rectangle(5, 3)
print(r.area())
```
If `Rectangle` did not implement `area()`, Python would raise an error when trying to create its object.

## Difference Between Abstraction and Encapsulation

**Abstraction** and **Encapsulation** are both important concepts in Object-Oriented Programming, but they focus on different ideas. Many beginners confuse them, so it’s important to clearly understand the difference.

**Abstraction** is about **hiding unnecessary details and showing only what is important**. It focuses on what an object can do, not how it does it. For example, when you use a mobile phone, you only see buttons and apps. You don’t see how the operating system or hardware works internally. In Python, abstraction is often implemented using **abstract classes** and **abstract methods**.

**Encapsulation**, on the other hand, is about **protecting data and controlling access to it**. It focuses on how data is stored and accessed safely. For example, in a bank account, you should not directly change the balance variable. Instead, you use methods like deposit or withdraw. In Python, encapsulation is achieved using **private variables**, **protected variables**, and **getter/setter methods**.

Example:
``` python
from abc import ABC, abstractmethod

# ----------- ABSTRACTION -----------
# Abstract class
class Vehicle(ABC):

    @abstractmethod
    def start(self):
        pass

    @abstractmethod
    def stop(self):
        pass


# Child class implementing abstract methods
class Car(Vehicle):
    def start(self):
        print("Car is starting...")

    def stop(self):
        print("Car is stopping...")


# ----------- ENCAPSULATION -----------
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner        # Public attribute
        self.__balance = balance  # Private attribute (Encapsulation)

    def deposit(self, amount):
        self.__balance += amount
        print("Deposited:", amount)

    def get_balance(self):
        return self.__balance     # Controlled access


# ----------- MAIN PROGRAM -----------
# Abstraction example
my_car = Car()
my_car.start()
my_car.stop()

# Encapsulation example
account = BankAccount("John", 5000)
account.deposit(1000)
print("Current Balance:", account.get_balance())

# This will cause error because __balance is private
# print(account.__balance)
```

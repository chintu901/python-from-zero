# Encapsulation in Python

**Encapsulation** is a concept in **Object-Oriented Programming** that means **wrapping data and methods together** inside a class and **controlling how they are accessed**. In simple words, it is about protecting an object’s internal data from being changed directly in a wrong way.

In real life, you don’t directly touch the engine parts of a car while driving. You use pedals and the steering wheel. The engine is hidden, and you interact with it through controlled interfaces. Encapsulation works the same way in programming: the internal data is hidden, and you interact with it using methods.

Encapsulation exists because **direct access to data can cause bugs**, **security issues**, and **unpredictable behavior**. If anyone can change variables freely, the program can break easily. By controlling access, you make your code safer and easier to maintain.

In Python, encapsulation is achieved by:
- Keeping data inside a class
- Using naming conventions to hide data (like `_variable` or `__variable`)
- Using methods to read or update data instead of accessing it directly

``` python
class BankAccount:
    def __init__(self, balance):
        self.balance = balance   # data is inside the class

    def show_balance(self):
        print("Balance:", self.balance)
```

## Public, Protected, and Private Members in Python

In Python, **class members (attributes and methods)** can be **public**, **protected**, or **private**. This is part of encapsulation and is used to control **how data should be accessed** and **modified**. Python does not strictly enforce access rules like some other languages, but it provides naming conventions that programmers follow.

**Public members**: are normal variables and methods that can be accessed from anywhere. By default, everything in Python is public.

``` python
class student:
    def __init__(self, name):
        self.name = name    # Public variable

s = Student("Rahul")
print(s.name)  # allowed
```
**Protected members**: are written with a **single underscore** `(_)`. They are meant to be used **only inside the class** or **its child classes**, but Python still allows access. This is more of a warning to developers: “Use this carefully.”

``` python
class Student:
    def __init__(self, name):
        self._name = name   # protected

s = Student("Rahul")
print(s._name)  # allowed, but not recommended
```

**Private members**: are written with **double underscores** `(__)`. They are intended to be **hidden from outside the class**. Python changes their names internally to prevent accidental access.

``` python
class Student:
    def __init__(self, name):
        self.__name = name   # private
```
> [!NOTE]
> Public members can be accessed freely, protected members are meant for internal use, and private members are used to strongly hide data inside a class.

## Name Mangling and How Private Variables Work

When you create a private variable using double underscores (like `__name`), Python **automatically changes its name internally**. This process is called **name mangling**. It prevents accidental access and conflicts in subclasses.

For example:
``` python
class Student:
    def __init__(self, name):
        self.__name = name

s = Student("Rahul")
# print(s.__name)  # Error
```
If you try to access `s.__name`, Python will give an error. That’s because Python internally renames it like this:

``` python
print(s._Student__name)
```

Name mangling exists because Python supports **inheritance**. If a child class also defines `__name`, Python will rename it differently, avoiding conflicts between parent and child variables.

## Getter and Setter Methods (Accessing and Modifying Data Safely)

**Getter and Setter methods** are special methods used to **read** and **update private data** in a **controlled way**. Instead of accessing variables directly, you use these methods so the class can control what values are allowed and how data is changed.

The idea exists because direct access to data can be dangerous. For example, someone could set a bank balance to a negative value or change important data by mistake. Getter and Setter methods act like security gates for your data.

A **getter method** is used to get (read) the value of a private variable.
A **setter method** is used to set (update) the value of a private variable.

``` python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance   # private variable

    def get_balance(self):         # getter
        return self.__balance

    def set_balance(self, amount): # setter
        if amount >= 0:
            self.__balance = amount
        else:
            print("Invalid balance!")
```
Using the class:
``` python
acc = BankAccount(1000)

print(acc.get_balance())   # 1000

acc.set_balance(1500)       # update balance
print(acc.get_balance())    # 1500

acc.set_balance(-500)        # not allowed
```
Here, you cannot directly change `__balance`, but you can safely modify it using the setter method. The class decides what is valid and what is not.

Getter and Setter methods are important in professional programming because they protect data, add validation, and make code easier to maintain. Many real-world systems like banking apps, games, and websites use this pattern.


# Foundations of Testing

## Introduction to Software Testing

Debugging helps you fix problems after they occur.
Testing helps you prevent problems before users encounter them.

Software testing is the process of verifying that your code behaves as expected under different conditions. Instead of manually checking results, we write code that automatically checks other code.

Testing ensures:
- Correct functionality
- Code reliability
- Stability during changes
- Fewer production bugs
- Higher confidence when refactoring

In professional development, testing is not optional — it is a core practice.

### Why Testing Is Important

As programs grow:
- Code becomes interconnected
- Small changes can break existing functionality
- Manual checking becomes inefficient

Testing solves this by:
- Automatically verifying behavior
- Detecting regressions
- Acting as documentation for expected behavior

Testing turns assumptions into verifiable guarantees.

### Types of Testing (Overview)

Before diving deeper, it’s important to understand the main categories:

**1. Unit Testing**

Tests individual functions or small components.

**2. Integration Testing**

Tests how multiple components work together.

**3. System Testing**

Tests the entire application as a whole.

In this file, we focus primarily on unit testing, which is the foundation of reliable software.

## Using `assert` for Simple Testing

The simplest way to test in Python is using the `assert` statement.

An `assert` checks whether a condition is true.
If the condition is false, Python raises an error.

Basic syntax:

``` python
assert condition
```

If the condition evaluates to `False`, Python raises an `AssertionError`.

**Example 1: Testing a Function**
``` python
def add(a, b):
    return a + b

assert add(2, 3) == 5
```

If the function works correctly, nothing happens.
If it returns the wrong value, the program stops with an error.

**Example 2: With Error Message**
``` python
assert add(2, 3) == 6, "Addition function failed"
```

If the test fails, Python displays:
``` python
AssertionError: Addition function failed
```

This helps identify the issue clearly.

### Important Limitation of `assert`

`assert` is not a full testing framework.

Limitations:
- Stops execution on first failure
- No detailed reporting
- No test grouping
- Not ideal for large applications

For serious testing, we use frameworks like Python’s built-in `unittest` or third-party tools like `pytest`.

But mastering `assert` builds the foundation.

**Example: Testing Edge Cases**

``` python
def divide(a, b):
    return a / b

assert divide(10, 2) == 5
```

Edge Cases:

``` python
try:
    divide(10, 0)
except ZeroDivisionError:
    pass
else:
    assert False, "Expected ZeroDivisionError"
```

This verifies correct error behavior.

### Professional Testing Mindset

Testing is not about proving your code works once.

It is about:
- Protecting future changes
- Documenting expected behavior
- Reducing fear when refactoring
- Building production-ready systems

The best developers:
- Write tests early
- Test edge cases
- Trust automated validation
- Avoid manual verification whenever possible

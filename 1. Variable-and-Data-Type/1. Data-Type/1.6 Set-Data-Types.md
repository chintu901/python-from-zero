# Set Data Types

Set data types in Python are used to **store multiple unique values** in a single variable.
Unlike lists or tuples, sets do not allow **duplicate elements** and do not follow any **specific order**.

**Sets are especially useful when you want to:**
- Remove duplicate values.
- Perform mathematical operations like union and intersection.
- Check membership efficiently.

``` python
numbers = {1,2,3,4,5}
print(numbers)
```

## Characteristics of Sets

Sets have some **important characteristics** that make them different from other data types.

**Unordered Collection:**

- Elements do not have a fixed order.
- Indexing and slicing are not supported.

``` python
numbers = {1,2,3,4}
print(number[0])    # TypeError
```

**Unique Elements Only:**

Duplicate values are **automatically removed**.

``` python
numbers = {1,1,2,3,3}
print(numbers)  # {1,2,3}
```
**No Indexing or Slicing:**

You cannot access elements using index positions.

**Mutability:**

- `set` is mutable (can be modified).
- `frozenset` is immutable (cannot be modified).

![Set data type diagram](https://pynative.com/wp-content/uploads/2021/03/python-sets.jpg)

> [!NOTE]
> Sets are ideal for uniqueness and mathematical operations, not ordered data storage.

## Types of Set Data Types

Python provides **two types of set data types**:

**Set (`set`):**

- Mutable (elements can be added or removed)
- Unordered
- Does not allow duplicate values

``` python
numbers = {1, 2, 3}
print(numbers)
```

**Frozen Set (frozenset):**

- Immutable (cannot be changed after creation)
- Unordered
- Does not allow duplicate values

``` python
numbers = frozenset([1, 2, 3, 4])
```

**Comparison Summary**

| Feature | Set | Frozenset |
|-------|-----|----------|
| Mutable | ✅ Yes | ❌ No |
| Allows duplicates | ❌ No  | ❌ No |
| Unordered | ✅ Yes | ❌ No |

> [!NOTE]
> Use `set` when data needs to change, and `frozenset` when data should remain fixed.

## Creating Sets

In Python, sets can be created in different ways depending on the situation.

**Using Curly Braces `{}`:**

This is the most common way to create a set.

``` python
fruits = {"apple", "banana", "Kiwi"}
print(fruits)
```

**Creating an Empty Set:**

An empty set must be created using `set()`.

``` python
empty_set = set()
```

❌ This creates an empty dictionary, not a set:

``` python
my_set = {}
```

**Creating a Frozenset:**

``` python
frozen = frozenset([1,2,3,4])
print(frozen)
```

## Accessing Elements in a Set

Sets do not support indexing or slicing because they are **unordered**.
Elements are accessed using **iteration** or **membership testing**.

**Iterating Through a Set:**

``` python
colors = {"red", "blue", "yellow"}

for color in colors:
    print(color)
```
**Membership Testing:**

Check whether an element exists in a set.

``` python
numbers = {10, 20, 30}

print(20 in numbers)        # True
print(40 not in numbers)    # True
```

> [!NOTE]
> Sets allow fast access using membership checks, not position-based access.

## Adding and Removing Elements in a Set

Sets are mutable, which means you can **add or remove elements after creation**.

| Method | Description | Example |
|-------|-----|----------|
| `add()` | Add a Single Element | `set_name.add("apple")` |
| `update()` | Add Multiple Elements | `set_name.update("banana", "kiwi")` |
| `remove()` | Removes an Element (Raises an error if the element does not exist.) | `set_name.remove("apple")` |
| `discard()` | Self removal (No error if element is missing) | `set_name.discard("banana")` |
| `pop()` | Removes a Random Element | `set_name.discard("banana")` |
| `clear()` | Removes All Elements | `set_name.clear()` |

**Example Program:**

``` python
# Creating a set
fruits = {"apple", "banana", "kiwi"}

print("Original set:", fruits)

# Adding an element to the set
fruits.add("mango")
print("After adding mango:", fruits)

# Adding multiple elements
fruits.update(["grapes", "orange"])
print("After adding grapes and oragne:", fruits)

# Removing an element
fruits.remove("grapes")
print("After removing grapes:", fruits)

# Removing an element safely
fruits.discard("watermelon")  # No error if element does not exist
print("After discard operation:", fruits)

# Removing an random element using pop()
fruits.pop()
print("After using pop():", fruits)

# Clear the fruits set
fruits.clear()
print("No elements:", fruits)
```

**Output:**

``` bash
Original set: {'kiwi', 'apple', 'banana'}
After adding mango: {'kiwi', 'mango', 'apple', 'banana'}
After adding grapes and oragne: {'apple', 'banana', 'mango', 'kiwi', 'orange', 'grapes'}
After removing grapes: {'apple', 'banana', 'mango', 'kiwi', 'orange'}
After discard operation: {'apple', 'banana', 'mango', 'kiwi', 'orange'}
After using pop(): {'banana', 'mango', 'kiwi', 'orange'}
No elements: set()
```

> [!NOTE]
> Use `discard()` when you are not sure whether the element exists.

## Set Operations

Set operations allow you to perform **mathematical operations** on sets.

**Union (`|` or `union()`):**

Combines elements from both sets.

``` python
a = {1,2,3}
b = {1,5,6}

print(a | b)    # {1, 2, 3, 5, 6}
```

**Intersection (`&` or `intersection()`):**

Common elements between sets.

``` python
print(a & b)
```

**Difference (`-` or `difference()`):**

Elements in the first set but not in the second.

``` python
print(a - b)    # {2, 3}
```

**Symmetric Difference (^):**

Elements that are in either set, but not both.

``` python
print(a ^ b)    # {2, 3, 5, 6}
```

> [!NOTE]
> Set operations make Python powerful for **data comparison**, **filtering**, and **analysis**.


## Set Methods

Python provides several built-in methods to **compare and work with sets**.

| Method | Decription | Example |
|-------|-----|----------|
| `copy()` | Copy a Set | `b.copy()` |
| `issubset()` | Check Subset | `a.issubset(b)` |
| `issuperset()` | Check Superset | `a.issuperset(b)` |
| `isdisjoint()` | Check if set have no Common Elements | `a.isdisjoint(b)` |
 
**Example Program:**

``` python
a = {1, 2, 3}
b = {1, 2}

# Make the copy of set b
c = b.copy()

# Check if set a is subset of set b
print(a.issubset(b))    # False

# Check if set a is supperset of set b
print(a.issupperset(b)) # True

# Check if sets have not common elements
print(a.isdisjoint(b))  # False
```

> [!NOTE]
> These methods help compare relationships between sets.

## Use Cases of Sets and Frozensets

Sets and frozensets are used when you need to work with unique data and perform fast comparisons. They are especially useful in real-world programming scenarios.

**1. Removing Duplicate Values:**

Sets automatically remove duplicates.

``` python
numbers = [1, 2, 2, 1, 4, 5]
unique = set(numbers)
print(unique)   # {1, 2, 4, 5}
```

**2. Fast Membership Testing:**

Checking whether an element exists is faster in sets than in lists.

``` python
users = {"admin", "alex", "joe"}
print("admin" in users)    # True
```

**3. Mathematical Set Operations:**

Used for union, intersection, and difference.

``` python
a = {1, 2, 3}
b = {3, 4, 5}

print("Common element:", a & b)    # Common element: {3}
```

**4. Filtering Data:**

Sets help filter common or unique values between collections.

``` python
allowed = {"read", "write"}
requested = {"read", "delete"}

print(allowed & requested)  # {'read'}
```

**5. Using Frozenset as Dictionary Keys:**

Since frozensets are immutable, they can be used as dictionary keys.

``` python
groups = {
    frozenset(["A", "B"]): "Group 1"
}
```

**6. Eliminating Repeated Computation:**

Sets help track visited items.

``` python
visited = set()
visited.add("page1")
```

> [!NOTE]
> Use sets for changing unique data and frozensets for fixed, hashable collections.

# Testing and Debugging

In **software development**, writing code is only half the job. The other half is making sure that the code works correctly and reliably. This is where **testing and debugging** come in.

**Testing** is the process of **checking whether your program behaves as expected**. It helps verify that your code produces correct outputs for given inputs. Testing is **proactive** â€” you write tests to prevent problems and ensure correctness.

**Debugging**, on the other hand, is the process of **finding and fixing errors (bugs)** in your code after something goes wrong. Debugging is **reactive** â€” it starts when a problem appears.

Although **testing** and **debugging** are related, they serve different purposes:
- Testing **finds problems**.
- Debugging **fixes problems**.

In real-world software development, untested code can lead to serious issues such as:
- Application crashes
- Incorrect data processing
- Security vulnerabilities
- Financial loss
- Poor user experience

Professional developers treat testing as a **core skill**, not an optional task. Writing reliable code means:
- Anticipating possible failures
- Validating assumptions
- Ensuring predictable behavior
- A strong testing and debugging mindset makes you:
- More confident in your code
- Faster at solving problems
- More professional as a developer

## Types of Errors in Python

Errors are a natural part of programming. Understanding the different types of errors helps you fix them efficiently and prevents frustration.

In Python, errors are generally categorized into three main types:

### 1ï¸âƒ£ Syntax Errors

A **syntax error** occurs when Python **cannot understand your code** because it breaks the **language rules**. These errors are detected before the program runs.

Example:

``` python
print("Hello"
```
Output:

``` python
SyntaxError: unexpected EOF while parsing
```

Common causes:
- Missing parentheses
- Incorrect indentation
- Missing colons (`:`)
- Misspelled keywords

Syntax errors are usually easy to fix because Python clearly points to the problematic line.

### 2ï¸âƒ£ Runtime Errors (Exceptions)

Runtime errors occur **while the program is running**. The syntax is correct, but something goes wrong during execution.

Example:

``` python 
a = 12/0
```

Output:

``` python
ZeroDivisionError: division by zero
```

Common runtime errors:
- `ZeroDivisionError`
- `TypeError`
- `ValueError`
- `IndexError`
- `KeyError`

Runtime errors stop program execution unless handled properly.

### 3ï¸âƒ£ Logical Errors

Logical errors are the most dangerous type. The program runs without crashing, but it produces **incorrect results**.

Example:
``` python
def add(a, b):
    return a - b  # mistake
```

The function runs, but gives wrong output.

Logical errors are harder to detect because:
- No error message appears
- The program behaves incorrectly but silently

These errors require careful testing to identify.

### ðŸ”Ž Comparing the Three Types

| Error Type | When It Occurs | Easy to Detect? |
|----------|----------|----------|
| Syntax Error | Before execution | Row 1 C3 |
| Runtime Error | During execution | Row 2 C3 |
| Logical Error | After execution | Row 2 C3 |

> [!NOTE]
> - Syntax errors break Python rules.
> - Runtime errors occur during execution.
> - Logical errors produce incorrect results.
> - Logical errors require testing to detect.

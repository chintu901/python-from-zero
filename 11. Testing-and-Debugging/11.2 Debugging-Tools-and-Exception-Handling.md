# Debugging Tools & Exception Handling

## Using Python Debugger (`pdb`)

While `print()` debugging is useful, professional developers use debugging tools that allow them to **pause execution** and **inspect code interactively**. Python provides a built-in debugger called `pdb`.

The Python Debugger allows you to:
- Pause execution at a specific line
- Inspect variable values
- Execute code step-by-step
- Control program flow

This gives you much more control than simple print statements.

**Starting the Debugger**

You can start `pdb` in different ways.

**Method 1:** Inserting Breakpoint in Code (Recommended in Modern Python)

``` python
def divide(a, b):
    breakpoint()
    return a / b

print(divide(10, 2))
```
When execution reaches `breakpoint()`, Python pauses and enters debug mode.

**Method 2:** Using `pdb` Module Directly

``` python
import pdb

pdb.set_trace()
```
**Common `pdb` Commands**

When the debugger starts, you can type commands:

| Command | Meaning | 
|-------|-----|
| `n` | Next line | 
| `s` | Step into function | 
| `c` | Continue execution | 
| `q` | Quit debugger | 
| `p variable` | Print variable value | 
| `l` | List surrounding code | 

Example:

``` css
(Pdb) p a
10
(Pdb) p b
2
```
When to Use `pdb`
- When print debugging becomes messy
- When you need step-by-step inspection
- When dealing with unexpected runtime behavior

## Exception Handling for Safer Code

Runtime errors (exceptions) can crash your program. Exception handling allows you to **manage errors gracefully** instead of letting the program stop unexpectedly.

Python provides the `try` and `except` blocks for handling exceptions.

**Basic Syntax:**

``` python
try:
    # risky code
except SomeError:
    # handle error
```

**Example: Handling Division by Zero**

``` python
try:
    result = 10 / 0
except ZeroDivisionError:
    print("You cannot divide by zero.")
```

Instead of crashing, the program prints a message and continues.

**Catching Multiple Exceptions**

``` python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
except ValueError:
    print("Invalid input. Please enter a number.")
except ZeroDivisionError:
    print("Cannot divide by zero.")
```

### Using `else` and `finally`

`else`

Runs if no exception occurs.

``` python
try:
    result = 10 / 2
except ZeroDivisionError:
    print("Error occurred.")
else:
    print("Success:", result)
```

`finally`

Always runs, whether an exception occurs or not.

``` python
try:
    file = open("data.txt")
except FileNotFoundError:
    print("File not found.")
finally:
    print("Execution completed.")
```

`finally` is useful for:
- Closing files
- Releasing resources
- Cleaning up

### Raising Custom Exceptions

You can manually raise errors using `raise`.

``` python
age = -5

if age < 0:
    raise ValueError("Age cannot be negative.")
```

This is useful for enforcing rules in your program.

### When Not to Overuse Exception Handling

Bad practice:
``` python
try:
    risky_code()
except:
    pass
```

Why this is dangerous:
- It hides errors.
- Makes debugging harder.
- Swallows important information.

Good practice:
- Catch specific exceptions.
- Handle errors meaningfully.

### Professional Exception Handling Principles
- Catch only what you can handle.
- Avoid broad `except:` blocks.
- Provide helpful error messages.
- Log errors in real-world applications.

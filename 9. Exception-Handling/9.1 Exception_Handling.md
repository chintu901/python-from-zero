# Exception Handling

An **exception** is an event that occurs when a **program encounters an error** during execution. Instead of stopping the entire program suddenly, Python raises an exception to inform the programmer that something went wrong. Exceptions exist to make programs safer and more predictable, especially when dealing with user input, files, or external systems.

Without exceptions, a single error could crash the whole application. With exception handling, programmers can **detect problems**, **show meaningful messages**, and allow the program to **continue running** or **exit gracefully**. This is extremely important in real-world applications like banking systems, games, and web apps where sudden crashes are unacceptable.

Example of an exception:

``` python
x = 10
y = 0
print(x / y)   # ZeroDivisionError
```
Here, Python raises an exception because dividing by zero is not allowed.

## Errors vs Exceptions in Python

In Python, **errors** and **exceptions** are related but not the same.

An **error** usually refers to a problem that happens due to **incorrect code syntax** or **structure**. These errors occur before the program runs and must be fixed before execution. For example, forgetting a colon or misspelling a keyword causes a syntax error.

Example of an error:

``` python
if a > 0
    print(f"number: {a}")
```
This code produces a `SyntaxError` and the program will not run.

An **exception**, on the other hand, occurs while the program is running. The code is syntactically correct, but something goes wrong during execution, such as dividing by zero or accessing an invalid index.

Example of an exception:

``` python
numbers = [1, 2, 3]
print(numbers[5])   # IndexError
```

## Common Built-in Exceptions in Python

Python provides many **built-in exceptions to handle different types of runtime problems**. These exceptions help programmers understand what went wrong and allow them to fix or handle the issue properly. As a beginner aiming to become a professional programmer, knowing common exceptions will help you debug faster and write safer code.

One of the most common exceptions is `ZeroDivisionError`. It occurs when a number is divided by zero, which is mathematically invalid.

``` python
a = int(input("a: "))   # user_input: 2
b = int(input("b: "))   # user_input: 0

print(a/b)  # ZeroDivisionError
```
Another frequently seen exception is `TypeError`. This happens when an **operation is applied to incompatible data types**, such as adding a number to a string.

``` python
a = 5
b = "4"

print(a+b)  # TypeError: Can't add 'int' with 'str'
```

The `ValueError` occurs when a **function receives a value of the correct type but an invalid value**. For example, trying to convert a non-numeric string into an integer.

``` python
a = int("seven")
print(a)    # ValueError
```

An `IndexError` happens when you try to **access a list element using an index that does not exist**.

``` python
list_item = [1, 2, "car"]
print(list_item[5])
```
The `KeyError` occurs when you try to **access a dictionary key that does not exist**.

``` python
data = {"name": "chetan"}
print(data["age"])
```
A `FileNotFoundError` is raised when Python **cannot find the file** you are trying to open.

``` python
file = open("data.txt")
```
These exceptions exist to clearly tell you what kind of problem occurred, making debugging easier and helping you write more reliable programs.

## The `try` and `except` Block

The `try` and `except` block is used in Python to handle **exceptions** safely. Instead of letting a program crash when an error occurs, Python allows you to **catch the error** and **decide what should happen next**. This makes programs more user-friendly and reliable.

The code that might cause an exception is placed inside the `try` block. If an exception occurs, Python immediately stops executing the `try` block and jumps to the `except` block. The `except` block contains the code that runs when an error happens.

Basic example:

``` python
try:
    x = 10
    y = 0
    print(x / y)
except:
    print("An error occurred")
```

Here, dividing by zero raises an exception. Instead of crashing, the program prints a friendly message.

You can also catch **specific exceptions**, which is a better practice than using a general except. This helps you handle different problems in different ways.

``` python
try:
    num = int("abc")
except ValueError:
    print("Invalid number input")
```

If no exception occurs inside the `try` block, the `except` block is skipped and the program continues normally.

The `try` and `except` block exists to **control program flow during errors**, **improve user experience**, and **prevent unexpected crashes** in real-world applications.

## The `else` Block and When to Use It

The `else` block in exception handling is used to run code only when **no exception occurs** in the try block. It helps separate normal logic from error-handling logic, making the program cleaner and easier to understand.

The flow works like this:
- `try` → code that may cause an exception
- `except` → runs if an exception occurs
- `else` → runs if no exception occurs

Example:

``` python
try:
    num = int(input("Enter a number: "))
except ValueError:
    print("Invalid input")
else:
    print("You entered:", num)
```

Here, if the user enters a valid number, the `else` block executes. If an error occurs, the `except` block runs and `else` is skipped.

The `else` block exists to clearly **separate successful execution code** from error-handling code, which is a good professional practice.

## The `finally` Block and Why It Matters

The `finally` block is used to **run code no matter what happens**—whether an exception occurs or not. It is mainly used for cleanup tasks like **closing files**, **releasing resources**, or **disconnecting from databases**.

The `finally` block always executes after try and except, even if an error occurs.

Example:

``` python
try:
    file = open("game.txt", "r")
    print(file.read())
except FileNotFoundError:
    print("Error: File not found")
finally:
    print("closing file")
```

In real applications, the `finally` block is important because it ensures that **resources are properly released**, **preventing memory leaks** and **system issues**.

> [!NOTE]
> The `finally` block always executes and is used to clean up resources, making programs safer and more reliable.

## Raising Exceptions Using `raise`

In Python, the `raise` keyword is used to **manually trigger an exception**. This is useful when you want to stop the program because a specific condition is invalid, even if Python itself would not raise an error automatically.

Raising exceptions exists to **enforce rules** in your program. It allows you to **catch problems early** and show clear error messages instead of letting incorrect data move through the system.

Example:

``` python
age = int(input("What's your age? "))

if age <= 0:
    raise ValueError("Age can't be less than 1")
print(f"Age: {age}")
```
Here, Python raises a `ValueError` when an invalid `age` is entered. This helps prevent incorrect values from being used later in the program.

Using `raise` makes your code more strict, safer, and easier to debug, especially in professional applications.

## Creating Custom Exceptions

Sometimes, built-in exceptions are not enough to clearly describe a problem. In such cases, Python allows you to **create custom exceptions** by defining your own **exception class**. This makes error messages more meaningful and easier to understand.

Custom exceptions are created by inheriting from the `Exception` class.

Example:

``` python
class InsufficientBalanceError(Exception):
    pass
```
Using the custom exception:
``` python 
balance = 500

withdraw_amount = 1000

if withdraw_amount > balance:
    raise InsufficientBalanceError("Not enough balance to withdraw")
```

Custom exceptions are commonly used in real-world systems like banking, payment apps, and APIs where specific error handling is required.
# Nested Conditionals

Nested conditionals are `if` statements placed inside another `if`, `elif`, or `else` block.
They allow a program to make **decisions in steps**, where the next check depends on the result of the previous one.

Instead of checking everything at once, the program:
- First checks a main condition
- Then checks more specific conditions only if the first condition is true

This creates a clear decision flow, similar to asking follow-up questions after an initial answer.

``` python
age = 20

if age >= 18:
    if age >= 21:
        print("You can vote and drink")
```

## Why Nested Conditionals Exist

Nested conditionals exist because some **decisions cannot be made with a single condition**.
In many real programs, **one rule must be confirmed before another rule** even matters.

They help by:
- Preventing unnecessary checks
- Reflecting real-world decision sequences
- Making complex logic easier to follow when order matters

For example, it makes sense to:
- Check if a user is logged in before checking permissions
- Verify input validity before processing data

Without nesting, these checks might run in the wrong order or make the code harder to understand.

## Basic Syntax of Nested `if` Statements

Nested conditionals follow the same rules as normal `if` statements, with **indentation playing a critical role**.
Each level of indentation represents a **new decision layer**.

The outer condition is checked first.
Only if it passes does Python move inside to evaluate the nested condition.

``` python
score = 85

if score >= 50:
    if score >= 90:
        print("Grade: A")
    else:
        print("Grade: B or C")
```

## Nested `if–else `and `if–elif–else` Combinations

Nested conditionals can include `else` and `elif` blocks to handle multiple outcomes inside a larger decision.

This allows a program to:
- Handle broad conditions first
- Then deal with detailed cases inside them

``` python
age = 22

if age >= 18:
    if age >= 21:
        print("Adult with full access")
    else:
        print("Adult with limited access")
else:
    print("Minor")
```

## Practical Example of Nested Conditionals

In real applications, this pattern is commonly used for validation, access control, and rule-based logic.

``` python
is_logged_in = True
role = "admin"

if is_logged_in:
    if role == "admin":
        print("Welcome, Admin. Full access granted.")
    elif role == "user":
        print("Welcome, User. Limited access granted.")
    else:
        print("Role not recognized.")
else:
    print("Please log in to continue.")
```

**How the Decision Flow Works:**
- The program first checks whether the user is logged in
- Only logged-in users are checked for their role
- Based on the role, different access levels are granted
- Users who are not logged in are stopped early

This ensures that:
- Unnecessary checks are avoided
- Logic follows a natural order
- Each condition runs only when relevant

> [!NOTE]
> Nested conditionals are most useful when decisions depend on earlier conditions, allowing programs to follow a clear, step-by-step logic flow.

# Classes and Objects

**Classes:** A class in Python is a **blueprint or template** that defines how something should **look** and **behave**. It describes what data an object will store and what actions it can perform. You can think of a class as a design plan, not the real thing. For example, a “Student” class describes what every student object should have, such as a name and age, and what it can do, such as display details.

``` python
class student:
    pass
```

**Objects:** An object is a **real instance created from a class**. When you create an object, Python allocates memory for it and stores its own data. If a class is a blueprint of a house, then an object is an actual house built using that blueprint. You can create many objects from the same class, and each object can have different data.

``` python
class Student:
    pass

s1 = Student()   # object 1
s2 = Student()   # object 2
```

The difference between a class and an object is simple: a class is just a design, while an object is the real thing created from that design. One class can produce unlimited objects, and all those objects follow the same structure defined by the class.

## Attributes (Variables Inside a Class)

Attributes are **variables that belong to a class or an object**.
They store data related to the object.

For example, a Student object can have attributes like:
- name
- age
- marks

In Python, attributes are usually created inside the class using `self`.

``` python
class Student:
    def __init__(self, name, age, marks):
        self.name = name    # attribute
        self.age =  age     # attribute
        self.marks = marks  # attribute
s1 = Student("Mohit", 21, 95)
s2 = Student("Chetan", 24, 85)
s3 = Student("Keshav", 24, 92)

print(s1.name)  # Mohit
print(s2.age)   # 24
```
Here:
- self.name and self.age are instance attributes
- Each object can have different values

## Methods (Functions Inside a Class)

Methods are **functions that belong to a class**. They define what an object can do. Just like attributes store data, methods define behavior. For example, a Student object can store a name and age (data), and it can also perform actions like displaying details or updating information (behavior). This is why methods are important—they give objects the ability to act, not just store values.

In Python, every method inside a class must have a **special first parameter called** `self`. The `self` keyword refers to the **current object**. It is how an object accesses its own data and functions. You don’t pass `self` manually when calling a method—Python does it automatically.

**Example:**

``` python
class Student:
    def __init__(self, name):
        self.name = name
    def greet(self):
        print(f"Hello, my name is: {self.name}")

s1 = Student("Chetan")
s1.show()   # Hello, my name is: Chetan
```

Here:
- `show` is a method.
- Python automatically passes `s1` as `self`. So the method knows which object is calling it.


## The Constructor (__init__ Method)

A constructor is a **special method** in Python that runs automatically when an **object is created**. In Python, the constructor is written as `__init__`. Its main purpose is to initialize (set up) the object’s data when it is created.

When you **create an object**, you often want it to start with some values, like a student’s name or age. Instead of setting those values manually after creating the object, the constructor lets you pass them directly while creating the object.

Here is a basic example:
``` python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

s1 = Student("Rahul", 20)
print(s1.name)
print(s1.age)
```

In this code, _  runs automatically when Student(`"Rahul"`, `20`) is executed. The values `"Rahul"` and `20` are stored in the object as attributes. The self keyword refers to the current object, so `self.name` and `self.age` become attributes of `s1`.

You can also give default values in a constructor, so the user doesn’t always need to pass data:

``` python
class Student:
    def __init__(self, name="Unknown", age=0):
        self.name = name
        self.age = age

s1 = Student()
s2 = Student("Aman", 18)
```

> [!NOTE]
> The `__init__` method is a constructor that runs automatically when an object is created and is used to initialize the object’s data.

## Special (Magic/Dunder) Methods

In Python, special methods (also called magic methods or dunder methods) are built-in methods with double underscores, like `__init__`,`__str__`, and `__len__`. They exist so your **custom classes can behave like built-in Python objects**.

For example, when you use `print()` on an object, Python internally calls the `__str__` method. When you use `len()` on an object, Python calls the `__len__` method. These methods let you control how your objects act with normal Python operations.

**Example:**

``` python
class Student:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"Student name is {self.name}"

s1 = Student("Rahul")
print(s1)
```
Without _`_str__`, Python would print something like `<__main__.Student object at 0x...>`, which is not user-friendly.

> [!NOTE]
> These methods exist so your custom classes can integrate smoothly with Python’s syntax and built-in functions, which is important in professional programming.

## Object-Oriented Design Basics

Object-Oriented Design is about **thinking before coding** and deciding how to **structure your program using classes and objects**. Instead of writing random functions, you design your code like real-world models. For example, in a school system, you might have classes like Student, Teacher, Course, and School.

Good design means each class has a **clear responsibility**. A Student class should handle student-related data and actions, not school payments or course scheduling. This makes code easier to understand, reuse, and maintain.

You should use OOP when your program has **real-world entities**, **repeated behavior**, or **complex relationships**. For very small scripts, simple functions may be better, but for large projects, OOP is almost always used.

Object-Oriented Design exists because large software systems would be impossible to manage without structure. Companies and professional developers rely heavily on good class design.

**Example:**

``` python 
class Student:
    def __init__(self, name, roll_no):
        self.name = name
        self.roll_no = roll_no

    def show_info(self):
        print(self.name, "has roll number", self.roll_no)


class Course:
    def __init__(self, course_name):
        self.course_name = course_name

    def show_course(self):
        print("Course:", self.course_name)
```

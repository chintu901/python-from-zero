# Function Baisc

A function is a **named block of code** that performs a specific task. Instead of writing the same logic again and again, you place it inside a function and reuse it whenever needed.

In simple terms, a function is like a tool:
- You define it once
- You use it many times
- It performs the same job each time

``` python
def greet():
    print("Hello, welcome!")
```

Here, the code inside `greet()` does not run immediately. It only runs when the function is **called**.

**Why Functions Exist?**

Functions exist because writing all logic in one place quickly becomes **messy and hard to maintain**. As programs grow, repetition and complexity increase.

Functions solve this by:
- Eliminating repeated code
- Making changes easier (update in one place)
- Improving debugging and testing

For example, if the same calculation is used in multiple places, placing it inside a function ensures consistency.

> [!NOTE]
> A function groups related code into a reusable block, reduce repetition, improve clarity, and make programs easier to maintain as they grow.

## Defining a Function

Defining a function means **creating the function** and **telling Python what task it should perform**. This is done using the `def` keyword, followed by the function name and parentheses.

**General structure:**

``` python
def function_name():
    # Code block
```
**Example:**

``` python
def display_message():
    print("Functions make code reusable.")
```
Important points while defining a function:
- The function name should be **meaningful** and **descriptive**.
- Parentheses () are mandatory.
- The code inside the function must be **indented**.
- Defining a function does **not execute it**.

> [!NOTE]
> Defining a function sets up reusable logic, but the code inside it runs only when the function is called.

## Calling a Function

Calling a function means **executing the code inside the function**. Until a function is called, Python simply stores its definition.

**Syntax:**

``` python
function_name()
```

**Example:**

``` python
def display_message():
    print("Functions make code reusable.")

display_message()
```

**Output:**

``` bash
Functions make code reusable
```

> [!NOTE]
> Calling a function triggers its execution, allowing the same block of code to run whenever needed without duplication.

## Function Parameters and Arguments

Functions become more powerful when they can **accept input values**. These input values are handled using **parameters** and **arguments**.

- **Parameters** are variables listed in the function definition.

- **Arguments** are the actual values passed to the function when it is called.

**Basic Structure:**

``` python
def greet(name):
    print(f"Hello {name}")
```

**Calling the function:**

``` python
greet("Mohit")
```

**Output:**

``` bash
Hello Mohit
```

**Here:**
- `name` â†’ parameter
- `"Mohit"` â†’ argument

**Multiple Parameters Example:**

``` python
def add(a, b):
    print(a + b)

add(5, 3)
```

> [!NOTE]
> Parameters allow functions to receive data from outside, making them dynamic, reusable, and adaptable to different situations.

## The `return` Statement

The `return` statement is used when a function needs to **send a result back** to the place where it was called. Instead of just displaying output on the screen, `return` allows the function to **produce a value that can be stored, reused, or further processed**.

Using `return` allows a function to:
- Provide a result instead of just printing it
- Be used in calculations or expressions
- Make programs more modular and flexible

A function without `return` performs an action, but a function with `return` **produces a value**.

### Example: Function Without `return`

``` python
def add(a, b):
    print(a + b)

result = add(5, 3)
print(result)
```

Output:

``` bash
8
None
```

Here, the function prints the sum but does not return it, so `result` becomes `None`.

### Example: Funtion with `return`

``` python
def add(a, b):
    return a + b

result = add(6, 2)
print(result)
```

Output:

``` bash
8
```

Here, the function prints the sum but does not return it, so result becomes None.

> [!NOTE]
> The `return` statement turns a function into a value-producing unit, allowing its result to be reused throughout the program instead of being limited to screen output.

## Function Scope (Local vs Global Variables)

Scope defines **where a variable can be accessed** in a program. When working with functions, understanding scope is important to avoid unexpected behavior.

**Local Variables:**
- Variables created inside a function
- Accessible only within that function
- Automatically removed after the function finishes execution

``` python
def show_number():
    x = 10   # local variable
    print(x)

show_number()
# print(x)  â†’ Error (x does not exist outside the function)
```

**Global Variables:**
- Variables created outside all functions
- Accessible anywhere in the program

``` python
y = 5  # global variable

def display():
    print(y)

display()
```

> ðŸ”¹ Best Practice: Prefer local variables unless global access is truly needed.

## Default Parameters

Default parameters allow a function to have **predefined values** for its parameters. This means the function can be called with or without providing those values, making it more flexible and easier to use.

Default parameters help when:
- A value is **optional**
- A function has a **common or standard behavior**
- You want to reduce repetitive arguments in function calls

They allow a function to work with less input while still behaving correctly.

``` python
def greet(name = "User"):
    print(f"Hello {name}")

greet()
greet("Mohit")
```

Output:

``` bash
Hello User
Hello Mohit
```
Here:
- `name` has a default value `"Hello"`
- If no argument is passed, the default is used
- If an argument is provided, it overrides the default


# Polymorphism 

**Polymorphism** is a concept in Object-Oriented Programming that means “**one thing, many forms**.” In simple words, it allows the same method or function name to behave differently for different objects.

Polymorphism exists because many objects share **similar actions** but perform them in **different ways**. For example, a Dog and a Cat both make a sound, but the sound is different. Instead of using different method names, polymorphism allows you to use the same method name like `sound()` for all animals.

Polymorphism makes code **flexible**, **clean**, and **easy to extend**. You can add new classes without changing existing code, which is very important in professional software development.

## Polymorphism with Methods (Same Method, Different Behavior)

In polymorphism with methods, different classes define a method with the same name, but each class provides its own behavior. This is usually done using method overriding in inheritance.

``` python
class animal:
    def sound(self):
        print("Animal makes sound")
class dog(animal):
    def sound(self):
        print("Dogs bark")
class cat(animal):
    def sound(self):
        print("cats meow")
```

Using the objects

``` python
a = animal()
d = dog()
c = cat()

a.sound()
d.sound()
c.sound()
```

Output will be different for each object, even though the method name is the same. Python decides which method to run based on the object type.

This is useful because you can write code that calls `sound()` on any animal, and each animal will behave correctly without extra conditions like `if` or `elif`.

## Method Overriding as Polymorphism

Method overriding is one of the most common ways to achieve **polymorphism** in Python. It happens when a child class redefines a method from the parent class, so the same method name behaves differently for different objects.

This is polymorphism because the **same method call can result in different outputs** depending on the object type. Python automatically chooses the correct method at runtime.

Example:

``` python
class Shape:
    def draw(self):
        print("Drawing a shape")

class Circle(Shape):
    def draw(self):
        print("Drawing a circle")

class Square(Shape):
    def draw(self):
        print("Drawing a square")
```

Using the objects:

``` python
s = Shape()
c = Circle()
sq = Square()

s.draw()
c.draw()
sq.draw()
```

## Polymorphism with Functions and Objects

Polymorphism in Python is not limited to inheritance. It also works with **functions and different object types**, as long as they support the same operation. This is part of Python’s dynamic nature.

For example, the built-in `len()` function works with many types of objects:

``` python
print(len("Hello"))   # string
print(len([1, 2, 3]))  # list
print(len((10, 20)))   # tuple
```

The same `len()` function behaves differently based on the object type.

You can also write your own function that works with different objects:

``` python
class Dog:
    def speak(self):
        print("Dog barks")

class Cat:
    def speak(self):
        print("Cat meows")

def make_sound(animal):
    animal.speak()

d = Dog()
c = Cat()

make_sound(d)
make_sound(c)
```
Here, the `make_sound` function does not care about the object type. It only cares that the object has a `speak()` method. This is polymorphism in functions and objects.

## Duck Typing in Python

**Duck Typing** is a Python concept that means “**if it behaves like a duck, treat it like a duck**.” In simple words, Python does not care about the object’s class type. It only cares about what the object can do.

In many languages, you must explicitly check the type of an object. In Python, you usually don’t. If an object has the required method or behavior, Python will use it. This makes Python flexible and powerful.

Example:
``` python
class Dog:
    def speak(self):
        print("Dog barks")

class Cat:
    def speak(self):
        print("Cat meows")

def make_sound(animal):
    animal.speak()

d = Dog()
c = Cat()

make_sound(d)
make_sound(c)
```
Here, `make_sound` does not check whether the object is `Dog` or `Cat`. It only assumes that the object has a `speak()` method. This is **duck typing**.

## Built-in Polymorphic Functions (len, print, etc.)

Python has many **built-in polymorphic functions** that work with different data types. These functions behave differently depending on the object passed to them.

For example:-
- `len()`
- `print()`

> [!NOTE]
> Built-in functions like `len()` and `print()` are polymorphic because they work with many data types and change behavior automatically.
